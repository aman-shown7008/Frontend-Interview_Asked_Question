1.  What is Strict mode in react ?
A.  StrictMode is a wrapper component in React that helps developers identify potential problems in their applications during development. It does not render anything in the UI but activates additional checks and warnings.

    Use / Purpose-
    ðŸ”¹Detects unsafe lifecycle methods.
    ðŸ”¹Warns about usage of deprecated APIs.
    ðŸ”¹Helps find side effects in components (like double rendering).
    ðŸ”¹Ensures best practices are followed for future React versions.

    StrictMode runs only in development, not in production.
    Itâ€™s safe â€” it wonâ€™t break your app, just gives warnings.
    Recommended to always use it at the root level of your React app.

    Warning that he warns-
    ðŸ”¹Double Rendering (Development Only).
    ðŸ”¹Unsafe Lifecycle Methods (in class components).
    ðŸ”¹Warns if you use old React features that will be removed.
    ðŸ”¹All useEffect, useLayoutEffect, and useInsertionEffect hooks are executed twice in development.
    ðŸ”¹Helps identify impure rendering logic (like modifying variables, doing API calls directly in render).

    ðŸ‘‰React StrictMode is a development-only tool to highlight potential problems (deprecated APIs, side effects, unsafe lifecycles) and enforce best practices.



2.  How would you optimize re-renders when data changes?
A.  Optimizing re-renders in React means making sure components only re-render when necessary. By default, React re-renders whenever props or state change, but sometimes not every component actually needs to update. Optimization helps avoid wasteful rendering and improves performance.
    Use / Purpose
    ðŸ”¹Makes apps faster and smoother, especially large ones.
    ðŸ”¹Avoids unnecessary DOM updates.
    ðŸ”¹Reduces CPU and memory usage.
    ðŸ”¹Helps handle large lists, heavy calculations, or frequent updates efficiently.

    Ways to Optimize-
    ðŸ”¹React.memo â€“ Skips re-render if props are the same.
    ðŸ”¹useMemo â€“ Caches expensive computations between renders.
    ðŸ”¹useCallback â€“ Caches function references to prevent re-renders of children.
    ðŸ”¹Splitting State â€“ Keep state as local as possible, avoid lifting too much.
    ðŸ”¹Avoid Inline Functions/Objects â€“ They create new references each render.
    ðŸ”¹Key Usage in Lists â€“ Use proper unique key to prevent re-renders of unchanged items.
    ðŸ”¹Windowing/Virtualization â€“ Render only visible list items (react-window, react-virtualized).
    ðŸ”¹Code Splitting/Lazy Loading â€“ Load only whatâ€™s needed.
    ðŸ”¹Avoid Unnecessary Context Usage â€“ Context re-renders all consumers, so use wisely.

    Depth Explanation
    ðŸ”¹Reactâ€™s default rendering is reconciliation-based: when state/props change, React re-renders and diffs the virtual DOM.
    ðŸ”¹If many components re-render unnecessarily, performance drops.
    ðŸ”¹Shallow comparison (done by React.memo) is key â€” if props havenâ€™t changed, no re-render.
    ðŸ”¹Expensive calculations (e.g., sorting, filtering, heavy loops) should be cached with useMemo.
    ðŸ”¹Functions are re-created on each render; passing them to children causes re-renders â†’ fix with useCallback.
    ðŸ”¹Context re-renders all consumers; avoid putting frequently changing values there.
    ðŸ”¹For huge lists (e.g., 10k items), donâ€™t render all â†’ use windowing so only visible items render.
    ðŸ”¹In React 18+, Reactâ€™s automatic batching reduces re-renders by grouping updates together.



























