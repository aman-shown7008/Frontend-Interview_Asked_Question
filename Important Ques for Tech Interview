1.  D/f b/w Package.JSON & Package-lock.JSON? Use-Case.
A.  Feature	                       package.json	                                                 package-lock.json
    Purpose                        Manages project metadata and dependencies.	                 Locks the exact versions of dependencies
    Contains	                   Dependency names & version ranges (e.g., ^ or ~).	         Exact versions of dependencies & sub-dependencies
    Versioning	                   Allows flexibility (^1.2.3 installs 1.x.x).    	             Ensures exact versions (1.2.3 remains 1.2.3)
    Human-readable?	               Yes, meant to be edited manually.	                         Not meant to be manually edited
    Generated?	                   Created manually when initializing a project (npm init).	     Auto-generated by npm when dependencies are installed
    Used By?	                   Developers to define dependencies.	                         npm to ensure reproducible installs

    Use-Case.
    Package.json
    🔹If we want to change version of any dependency OR want to delete that dependency so we can after running npm i.
    🔹Allows flexibility in dependency versions for future updates.

    Package-lock.json
    🔹Ensures consistency by locking dependency versions, preventing unexpected updates.
    🔹package-lock.json is for making sure the versions don’t change unexpectedly.



2.  D/f b/w Axios and Fetch? Use-Case.
A.  Axios → A third-party library to make HTTP requests easily. It has built-in features like automatic JSON parsing, error handling, and request cancellation.
    Fetch → A built-in JavaScript function for making HTTP requests. It's lightweight but requires extra steps for handling errors and responses.
    🔹 Think of Axios as a ready-to-eat meal 🍽️, while Fetch is raw ingredients 🍅🥩—you need to cook it yourself!
    🔹Axios automatically parses JSON, while Fetch needs response.json().
    🔹Axios catches HTTP errors automatically, but Fetch needs a manual check (if (!response.ok)).
    🔹Axios has a cleaner syntax with fewer steps.



3.  What state management solutions do you follow? And what is the need of it.
A.  I usually use Redux for complex applications where multiple components need access to shared state. For smaller or less complex applications, I sometimes use Context API for lightweight state sharing.
    The main reason we use state management solutions is to handle global state—data that needs to be accessed and updated across multiple parts of the app. Without proper state management, it becomes difficult to maintain consistency, especially when components are deeply nested or when data flow gets too complex.
    These tools help improve scalability, maintainability, and debugging in large applications.

    Uses of ContextAPI - 
    🔸 Use Case: You want to allow the user to switch between light and dark themes, and this theme should be available across the entire app — in header, footer, dashboard, etc.
    🔸 Why Context API?
        It’s a global value needed across many components.
        Doesn’t change frequently.
        Doesn’t require complex logic.
        No async or API calls involved.

    Use of Redux-Toolkit- 
    🔸 Use Case: An online store where:
                 User adds/removes items to/from cart
                 Cart total is calculated
                 Cart is used in multiple places: Product page, Cart page, Header, Checkout
                 You may even sync cart with backend (async)

    🔸 Why Redux?
       The state is shared across many components.
       It’s dynamic — user actions change the state often.
       Requires asynchronous logic (e.g., fetch product info, sync cart with backend).
       Needs central control for better tracking and testing.



4.  What is Exception handling? And how can we handle it.
A.  Exception Handling is a way to manage errors (also known as exceptions) that occur while a program is running, without crashing the entire application.
    In frontend development, these errors can come from:
    🔸API calls failing.
    🔸JSON parsing issues.
    🔸Incorrect user input.
    🔸DOM manipulation errors.
    🔸Network issues.
    🔸Unexpected data from server.
    Instead of letting the app crash, exception handling allows you to gracefully catch and respond to those problems — like showing an error message, retrying, or giving fallback UI.
    Scenario:
    🔁You’re building a weather app. It fetches current temperature from an API when the user clicks "Get Weather". But let’s say the user loses internet connection or the server is down. The fetch call will fail — if not handled, the app might crash or freeze.
    🛒You're building an e-commerce website.
    🔸User clicks on a product.
    🔸You send a request to the API to get product details.
    🔸But — description is missing, or the API fails.
    🔸Instead of crashing or showing empty space, you use a catch block (or condition) to show:
    🔸A default image
    🔸A "Description not available" message
    So we handle this with a try...catch block.
    Ex - import axios from "axios";
         async function fetchProductDetails(productId) {
           try {
             const res = await axios.get(`/api/products/${productId}`);
             setProduct(res.data);
           } catch (error) {
             console.error("Error fetching product:", error.message);
             setProduct({ description: "Description not available", image: "/fallback.png" });
           }
         }



5.  What is difference b/w Framework & Library?
A.  Library -
    🔸A library is a collection of pre-written code that provides specific functionality.
    🔸It gives full control to the developer over the application’s structure and flow.
    🔸Perfect for adding functionality into an existing app without refactoring.
    Ex - Bootstrap sets the styling conventions (like .btn, .btn-primary).
         You follow the class structure Bootstrap expects.
         You can’t easily customize without overriding the default styles.
         Bootstrap provides the full structure & style.
         Developer uses predefined classes like card, btn, card-title.

    Framework - 
    🔸A framework provides a structured foundation for building applications.
    🔸Built-in features like routing, state management, and templating save time.
    🔸Everyone follows the same conventions, making code more maintainable and readable.
    Ex - Material UI provides component-level utilities.
         You are in full control — you just use the parts you need.
         Easy to customize using props or override styles via sx or theme.
         Material UI provides components as building blocks.
         You customize with props and design freely.






























