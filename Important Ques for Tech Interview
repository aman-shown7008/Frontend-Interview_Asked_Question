1.  D/f b/w Package.JSON & Package-lock.JSON? Use-Case.
A.  Feature	                       package.json	                                                 package-lock.json
    Purpose                        Manages project metadata and dependencies.	                 Locks the exact versions of dependencies
    Contains	                   Dependency names & version ranges (e.g., ^ or ~).	         Exact versions of dependencies & sub-dependencies
    Versioning	                   Allows flexibility (^1.2.3 installs 1.x.x).    	             Ensures exact versions (1.2.3 remains 1.2.3)
    Human-readable?	               Yes, meant to be edited manually.	                         Not meant to be manually edited
    Generated?	                   Created manually when initializing a project (npm init).	     Auto-generated by npm when dependencies are installed
    Used By?	                   Developers to define dependencies.	                         npm to ensure reproducible installs

    Use-Case.
    Package.json
    ğŸ”¹If we want to change version of any dependency OR want to delete that dependency so we can after running npm i.
    ğŸ”¹Allows flexibility in dependency versions for future updates.

    Package-lock.json
    ğŸ”¹Ensures consistency by locking dependency versions, preventing unexpected updates.
    ğŸ”¹package-lock.json is for making sure the versions donâ€™t change unexpectedly.



2.  D/f b/w Axios and Fetch? Use-Case.
A.  Axios â†’ A third-party library to make HTTP requests easily. It has built-in features like automatic JSON parsing, error handling, and request cancellation.
    Fetch â†’ A built-in JavaScript function for making HTTP requests. It's lightweight but requires extra steps for handling errors and responses.
    ğŸ”¹ Think of Axios as a ready-to-eat meal ğŸ½ï¸, while Fetch is raw ingredients ğŸ…ğŸ¥©â€”you need to cook it yourself!
    ğŸ”¹Axios automatically parses JSON, while Fetch needs response.json().
    ğŸ”¹Axios catches HTTP errors automatically, but Fetch needs a manual check (if (!response.ok)).
    ğŸ”¹Axios has a cleaner syntax with fewer steps.



3.  What state management solutions do you follow? And what is the need of it.
A.  I usually use Redux for complex applications where multiple components need access to shared state. For smaller or less complex applications, I sometimes use Context API for lightweight state sharing.
    The main reason we use state management solutions is to handle global stateâ€”data that needs to be accessed and updated across multiple parts of the app. Without proper state management, it becomes difficult to maintain consistency, especially when components are deeply nested or when data flow gets too complex.
    These tools help improve scalability, maintainability, and debugging in large applications.

    Uses of ContextAPI - 
    ğŸ”¸ Use Case: You want to allow the user to switch between light and dark themes, and this theme should be available across the entire app â€” in header, footer, dashboard, etc.
    ğŸ”¸ Why Context API?
        Itâ€™s a global value needed across many components.
        Doesnâ€™t change frequently.
        Doesnâ€™t require complex logic.
        No async or API calls involved.

    Use of Redux-Toolkit- 
    ğŸ”¸ Use Case: An online store where:
                 User adds/removes items to/from cart
                 Cart total is calculated
                 Cart is used in multiple places: Product page, Cart page, Header, Checkout
                 You may even sync cart with backend (async)

    ğŸ”¸ Why Redux?
       The state is shared across many components.
       Itâ€™s dynamic â€” user actions change the state often.
       Requires asynchronous logic (e.g., fetch product info, sync cart with backend).
       Needs central control for better tracking and testing.




































